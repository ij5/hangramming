use std::str::FromStr;
use crate::ast::{OpCode, Expr, CompOpCode};

#[LALR]
grammar;

pub Program: Box<Expr> = {
  Comparison,
};

Comparison: Box<Expr> = {
  <l:Comparison> r"이|가" <r:Expr> <o:CompOp> => Box::new(Expr::CompOp(l, o, r)),
  Expr,
  FnCall,
};

FnCall: Box<Expr> = {
  <n:Identifier> "(" <p:(Parameters)?> ")" => {
    match p {
      Some(pp) => Box::new(Expr::FnCall(n, pp)),
      None => Box::new(Expr::FnCall(n, vec![])),
    }
  },
};

Parameters: Vec<Box<Expr>> = {
  <l:Comparison> <r:("," Comparison)*> => {
    let mut v:Vec<Box<Expr>> = vec![];
    v.push(l);
    for i in &r {
      v.push(Box::new(*i.1.clone()));
    }
    v
  }
};

Expr: Box<Expr> = {
  <l:Expr> <o:ExprOp> <r:Factor> => Box::new(Expr::Op(l, o, r)),
  Factor,
};

Factor: Box<Expr> = {
  <l:Factor> <o:FactorOp> <r:Term> => Box::new(Expr::Op(l, o, r)),
  Term,
};

Term: Box<Expr> = {
  <n:Int> => Box::new(Expr::Int(n)),
  <n:Float> => Box::new(Expr::Float(n)),
  "(" <e:Expr> ")" => e,
};

CompOp: CompOpCode = {
  r"과|와" "같으면" => CompOpCode::Eq,
  r"과|와" "다르면" => CompOpCode::NotEq,
  "보다" "크면" => CompOpCode::Gt,
  "보다" "작으면" => CompOpCode::Lt,
  "보다" "크거나" "같으면" => CompOpCode::GtE,
  "보다" "작거나" "같으면" => CompOpCode::LtE,
};

ExprOp: OpCode = {
  "더하기" => OpCode::Add,
  "빼기" => OpCode::Sub,
};


FactorOp: OpCode = {
  "곱하기" => OpCode::Mul,
  "나누기" => OpCode::Div,
};

Identifier: String = <s:r"[_a-zA-Zㄱ-ㅎ가-힣][_a-zA-Z0-9ㄱ-ㅎ가-힣]*"> => String::from(s);

Int: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();

Float: f32 = <s:r"[0-9]+\.[0-9]+"> => f32::from_str(s).unwrap();

Comment: () = {
  <c:r"//[^\n\r]*[\n\r]*"> => {},
  <c:r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/"> => {},
};

match{
  r"이|가",
  r"과|와",
  "(",
  ")",
  "같으면",
  "다르면",
  "보다",
  "크면",
  "작으면",
  "크거나",
  "작거나",
  "더하기",
  "빼기",
  "곱하기",
  "나누기",
  ",",
}else{
  r"[_a-zA-Zㄱ-ㅎ가-힣][_a-zA-Z0-9ㄱ-ㅎ가-힣]*",
  r"//[^\n\r]*[\n\r]*",
  r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/",
  r"[0-9]+\.[0-9]+",
  r"[0-9]+",
}